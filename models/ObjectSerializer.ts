export * from "./AccountRequest";
export * from "./AccountResult";
export * from "./AccountStatus";
export * from "./AccountType";
export * from "./AddToConference";
export * from "./AddToConferenceNotificationWebhook";
export * from "./AddToQueueNotificationWebhook";
export * from "./AnsweredBy";
export * from "./ApplicationList";
export * from "./ApplicationRequest";
export * from "./ApplicationResult";
export * from "./AvailableNumber";
export * from "./AvailableNumberList";
export * from "./BargeInReason";
export * from "./BuyIncomingNumberRequest";
export * from "./CallControlWebhook";
export * from "./CallDirection";
export * from "./CallEndedReason";
export * from "./CallList";
export * from "./CallResult";
export * from "./CallStatus";
export * from "./CallStatusWebhook";
export * from "./Capabilities";
export * from "./CompletionRequest";
export * from "./CompletionResult";
export * from "./CompletionResultStatus";
export * from "./ConferenceList";
export * from "./ConferenceParticipantList";
export * from "./ConferenceParticipantResult";
export * from "./ConferenceRecordingStatusWebhook";
export * from "./ConferenceResult";
export * from "./ConferenceStatus";
export * from "./ConferenceStatusWebhook";
export * from "./CreateConference";
export * from "./CreateConferenceRequest";
export * from "./CreateConferenceWebhook";
export * from "./CreateWebRTCToken";
export * from "./Dequeue";
export * from "./DequeueWebhook";
export * from "./Enqueue";
export * from "./ExportList";
export * from "./ExportOutputType";
export * from "./ExportRequest";
export * from "./ExportRequestOutput";
export * from "./ExportResourceType";
export * from "./ExportResult";
export * from "./ExportResultOutput";
export * from "./ExportStatus";
export * from "./FilterLogsRequest";
export * from "./GetDigits";
export * from "./GetDigitsReason";
export * from "./GetDigitsWebhook";
export * from "./GetSpeech";
export * from "./GetSpeechReason";
export * from "./GetSpeechWebhook";
export * from "./GrammarFileBuiltIn";
export * from "./GrammarType";
export * from "./Hangup";
export * from "./IfMachine";
export * from "./InboundCallWebhook";
export * from "./IncomingNumberList";
export * from "./IncomingNumberRequest";
export * from "./IncomingNumberResult";
export * from "./Language";
export * from "./LeaveConferenceWebhook";
export * from "./LogLevel";
export * from "./LogList";
export * from "./LogResult";
export * from "./MachineDetectedWebhook";
export * from "./MachineType";
export * from "./MakeCallRequest";
export * from "./MessageDeliveryWebhook";
export * from "./MessageDirection";
export * from "./MessageRequest";
export * from "./MessageResult";
export * from "./MessageStatus";
export * from "./MessageStatusWebhook";
export * from "./MessagesList";
export * from "./MutableResourceModel";
export * from "./OutDial";
export * from "./OutDialApiConnectWebhook";
export * from "./OutDialConnectWebhook";
export * from "./OutDialStartWebhook";
export * from "./PaginationModel";
export * from "./Park";
export * from "./Pause";
export * from "./PerclCommand";
export * from "./PerclScript";
export * from "./Play";
export * from "./PlayBeep";
export * from "./PlayEarlyMedia";
export * from "./QueueList";
export * from "./QueueMember";
export * from "./QueueMemberList";
export * from "./QueueRequest";
export * from "./QueueResult";
export * from "./QueueResultStatus";
export * from "./QueueWaitWebhook";
export * from "./RecordUtterance";
export * from "./RecordUtteranceTermReason";
export * from "./RecordWebhook";
export * from "./RecordingList";
export * from "./RecordingResult";
export * from "./Redirect";
export * from "./RedirectWebhook";
export * from "./Reject";
export * from "./RemoveFromConference";
export * from "./RemoveFromQueueNotificationWebhook";
export * from "./RequestType";
export * from "./SMSTenDLCBrand";
export * from "./SMSTenDLCBrandAltBusinessIdType";
export * from "./SMSTenDLCBrandEntityType";
export * from "./SMSTenDLCBrandIdentityStatus";
export * from "./SMSTenDLCBrandRelationship";
export * from "./SMSTenDLCBrandStockExchange";
export * from "./SMSTenDLCBrandsListResult";
export * from "./SMSTenDLCCampaign";
export * from "./SMSTenDLCCampaignStatus";
export * from "./SMSTenDLCCampaignsListResult";
export * from "./SMSTenDLCPartnerCampaign";
export * from "./SMSTenDLCPartnerCampaignBrand";
export * from "./SMSTenDLCPartnerCampaignStatus";
export * from "./SMSTenDLCPartnerCampaignsListResult";
export * from "./SMSTollFreeCampaign";
export * from "./SMSTollFreeCampaignRegistrationStatus";
export * from "./SMSTollFreeCampaignsListResult";
export * from "./Say";
export * from "./SendDigits";
export * from "./SetDTMFPassThrough";
export * from "./SetListen";
export * from "./SetTalk";
export * from "./Sms";
export * from "./StartRecordCall";
export * from "./TFN";
export * from "./TFNCampaign";
export * from "./TerminateConference";
export * from "./TranscribeReason";
export * from "./TranscribeTermReason";
export * from "./TranscribeUtterance";
export * from "./TranscribeUtteranceRecord";
export * from "./TranscribeWebhook";
export * from "./Unpark";
export * from "./UpdateCallRequest";
export * from "./UpdateCallRequestStatus";
export * from "./UpdateConferenceParticipantRequest";
export * from "./UpdateConferenceRequest";
export * from "./UpdateConferenceRequestStatus";
export * from "./Webhook";

import { AccountRequest } from "./AccountRequest";
import { AccountResult } from "./AccountResult";
import { AccountStatus } from "./AccountStatus";
import { AccountType } from "./AccountType";
import { AddToConference } from "./AddToConference";
import { AddToConferenceNotificationWebhook } from "./AddToConferenceNotificationWebhook";
import { AddToQueueNotificationWebhook } from "./AddToQueueNotificationWebhook";
import { AnsweredBy } from "./AnsweredBy";
import { ApplicationList } from "./ApplicationList";
import { ApplicationRequest } from "./ApplicationRequest";
import { ApplicationResult } from "./ApplicationResult";
import { AvailableNumber } from "./AvailableNumber";
import { AvailableNumberList } from "./AvailableNumberList";
import { BargeInReason } from "./BargeInReason";
import { BuyIncomingNumberRequest } from "./BuyIncomingNumberRequest";
import { CallControlWebhook } from "./CallControlWebhook";
import { CallDirection } from "./CallDirection";
import { CallEndedReason } from "./CallEndedReason";
import { CallList } from "./CallList";
import { CallResult } from "./CallResult";
import { CallStatus } from "./CallStatus";
import { CallStatusWebhook } from "./CallStatusWebhook";
import { Capabilities } from "./Capabilities";
import { CompletionRequest } from "./CompletionRequest";
import { CompletionResult } from "./CompletionResult";
import { CompletionResultStatus } from "./CompletionResultStatus";
import { ConferenceList } from "./ConferenceList";
import { ConferenceParticipantList } from "./ConferenceParticipantList";
import { ConferenceParticipantResult } from "./ConferenceParticipantResult";
import { ConferenceRecordingStatusWebhook } from "./ConferenceRecordingStatusWebhook";
import { ConferenceResult } from "./ConferenceResult";
import { ConferenceStatus } from "./ConferenceStatus";
import { ConferenceStatusWebhook } from "./ConferenceStatusWebhook";
import { CreateConference } from "./CreateConference";
import { CreateConferenceRequest } from "./CreateConferenceRequest";
import { CreateConferenceWebhook } from "./CreateConferenceWebhook";
import { CreateWebRTCToken } from "./CreateWebRTCToken";
import { Dequeue } from "./Dequeue";
import { DequeueWebhook } from "./DequeueWebhook";
import { Enqueue } from "./Enqueue";
import { ExportList } from "./ExportList";
import { ExportOutputType } from "./ExportOutputType";
import { ExportRequest } from "./ExportRequest";
import { ExportRequestOutput } from "./ExportRequestOutput";
import { ExportResourceType } from "./ExportResourceType";
import { ExportResult } from "./ExportResult";
import { ExportResultOutput } from "./ExportResultOutput";
import { ExportStatus } from "./ExportStatus";
import { FilterLogsRequest } from "./FilterLogsRequest";
import { GetDigits } from "./GetDigits";
import { GetDigitsReason } from "./GetDigitsReason";
import { GetDigitsWebhook } from "./GetDigitsWebhook";
import { GetSpeech } from "./GetSpeech";
import { GetSpeechReason } from "./GetSpeechReason";
import { GetSpeechWebhook } from "./GetSpeechWebhook";
import { GrammarFileBuiltIn } from "./GrammarFileBuiltIn";
import { GrammarType } from "./GrammarType";
import { Hangup } from "./Hangup";
import { IfMachine } from "./IfMachine";
import { InboundCallWebhook } from "./InboundCallWebhook";
import { IncomingNumberList } from "./IncomingNumberList";
import { IncomingNumberRequest } from "./IncomingNumberRequest";
import { IncomingNumberResult } from "./IncomingNumberResult";
import { Language } from "./Language";
import { LeaveConferenceWebhook } from "./LeaveConferenceWebhook";
import { LogLevel } from "./LogLevel";
import { LogList } from "./LogList";
import { LogResult } from "./LogResult";
import { MachineDetectedWebhook } from "./MachineDetectedWebhook";
import { MachineType } from "./MachineType";
import { MakeCallRequest } from "./MakeCallRequest";
import { MessageDeliveryWebhook } from "./MessageDeliveryWebhook";
import { MessageDirection } from "./MessageDirection";
import { MessageRequest } from "./MessageRequest";
import { MessageResult } from "./MessageResult";
import { MessageStatus } from "./MessageStatus";
import { MessageStatusWebhook } from "./MessageStatusWebhook";
import { MessagesList } from "./MessagesList";
import { MutableResourceModel } from "./MutableResourceModel";
import { OutDial } from "./OutDial";
import { OutDialApiConnectWebhook } from "./OutDialApiConnectWebhook";
import { OutDialConnectWebhook } from "./OutDialConnectWebhook";
import { OutDialStartWebhook } from "./OutDialStartWebhook";
import { PaginationModel } from "./PaginationModel";
import { Park } from "./Park";
import { Pause } from "./Pause";
import { PerclCommand } from "./PerclCommand";
import { PerclScript } from "./PerclScript";
import { Play } from "./Play";
import { PlayBeep } from "./PlayBeep";
import { PlayEarlyMedia } from "./PlayEarlyMedia";
import { QueueList } from "./QueueList";
import { QueueMember } from "./QueueMember";
import { QueueMemberList } from "./QueueMemberList";
import { QueueRequest } from "./QueueRequest";
import { QueueResult } from "./QueueResult";
import { QueueResultStatus } from "./QueueResultStatus";
import { QueueWaitWebhook } from "./QueueWaitWebhook";
import { RecordUtterance } from "./RecordUtterance";
import { RecordUtteranceTermReason } from "./RecordUtteranceTermReason";
import { RecordWebhook } from "./RecordWebhook";
import { RecordingList } from "./RecordingList";
import { RecordingResult } from "./RecordingResult";
import { Redirect } from "./Redirect";
import { RedirectWebhook } from "./RedirectWebhook";
import { Reject } from "./Reject";
import { RemoveFromConference } from "./RemoveFromConference";
import { RemoveFromQueueNotificationWebhook } from "./RemoveFromQueueNotificationWebhook";
import { RequestType } from "./RequestType";
import { SMSTenDLCBrand } from "./SMSTenDLCBrand";
import { SMSTenDLCBrandAltBusinessIdType } from "./SMSTenDLCBrandAltBusinessIdType";
import { SMSTenDLCBrandEntityType } from "./SMSTenDLCBrandEntityType";
import { SMSTenDLCBrandIdentityStatus } from "./SMSTenDLCBrandIdentityStatus";
import { SMSTenDLCBrandRelationship } from "./SMSTenDLCBrandRelationship";
import { SMSTenDLCBrandStockExchange } from "./SMSTenDLCBrandStockExchange";
import { SMSTenDLCBrandsListResult } from "./SMSTenDLCBrandsListResult";
import { SMSTenDLCCampaign } from "./SMSTenDLCCampaign";
import { SMSTenDLCCampaignStatus } from "./SMSTenDLCCampaignStatus";
import { SMSTenDLCCampaignsListResult } from "./SMSTenDLCCampaignsListResult";
import { SMSTenDLCPartnerCampaign } from "./SMSTenDLCPartnerCampaign";
import { SMSTenDLCPartnerCampaignBrand } from "./SMSTenDLCPartnerCampaignBrand";
import { SMSTenDLCPartnerCampaignStatus } from "./SMSTenDLCPartnerCampaignStatus";
import { SMSTenDLCPartnerCampaignsListResult } from "./SMSTenDLCPartnerCampaignsListResult";
import { SMSTollFreeCampaign } from "./SMSTollFreeCampaign";
import { SMSTollFreeCampaignRegistrationStatus } from "./SMSTollFreeCampaignRegistrationStatus";
import { SMSTollFreeCampaignsListResult } from "./SMSTollFreeCampaignsListResult";
import { Say } from "./Say";
import { SendDigits } from "./SendDigits";
import { SetDTMFPassThrough } from "./SetDTMFPassThrough";
import { SetListen } from "./SetListen";
import { SetTalk } from "./SetTalk";
import { Sms } from "./Sms";
import { StartRecordCall } from "./StartRecordCall";
import { TFN } from "./TFN";
import { TFNCampaign } from "./TFNCampaign";
import { TerminateConference } from "./TerminateConference";
import { TranscribeReason } from "./TranscribeReason";
import { TranscribeTermReason } from "./TranscribeTermReason";
import { TranscribeUtterance } from "./TranscribeUtterance";
import { TranscribeUtteranceRecord } from "./TranscribeUtteranceRecord";
import { TranscribeWebhook } from "./TranscribeWebhook";
import { Unpark } from "./Unpark";
import { UpdateCallRequest } from "./UpdateCallRequest";
import { UpdateCallRequestStatus } from "./UpdateCallRequestStatus";
import { UpdateConferenceParticipantRequest } from "./UpdateConferenceParticipantRequest";
import { UpdateConferenceRequest } from "./UpdateConferenceRequest";
import { UpdateConferenceRequestStatus } from "./UpdateConferenceRequestStatus";
import { Webhook } from "./Webhook";

/* tslint:disable:no-unused-variable */
let primitives = [
  "string",
  "boolean",
  "double",
  "integer",
  "long",
  "float",
  "number",
  "any",
];

const supportedMediaTypes: { [mediaType: string]: number } = {
  "application/json": Infinity,
  "application/octet-stream": 0,
  "application/x-www-form-urlencoded": 0,
};

let enumsMap: Set<string> = new Set<string>([
  "AccountStatus",
  "AccountType",
  "AnsweredBy",
  "BargeInReason",
  "CallDirection",
  "CallEndedReason",
  "CallStatus",
  "CompletionResultStatus",
  "ConferenceStatus",
  "ExportOutputType",
  "ExportResourceType",
  "ExportStatus",
  "GetDigitsReason",
  "GetSpeechReason",
  "GrammarFileBuiltIn",
  "GrammarType",
  "IfMachine",
  "Language",
  "LogLevel",
  "MachineType",
  "MessageDirection",
  "MessageStatus",
  "PlayBeep",
  "QueueResultStatus",
  "RecordUtteranceTermReason",
  "RequestType",
  "SMSTenDLCBrandAltBusinessIdType",
  "SMSTenDLCBrandEntityType",
  "SMSTenDLCBrandIdentityStatus",
  "SMSTenDLCBrandRelationship",
  "SMSTenDLCBrandStockExchange",
  "SMSTenDLCCampaignStatus",
  "SMSTenDLCPartnerCampaignStatus",
  "SMSTollFreeCampaignRegistrationStatus",
  "TranscribeReason",
  "TranscribeTermReason",
  "UpdateCallRequestStatus",
  "UpdateConferenceRequestStatus",
]);

let typeMap: { [index: string]: any } = {
  AccountRequest: AccountRequest,
  AccountResult: AccountResult,
  AddToConference: AddToConference,
  AddToConferenceNotificationWebhook: AddToConferenceNotificationWebhook,
  AddToQueueNotificationWebhook: AddToQueueNotificationWebhook,
  ApplicationList: ApplicationList,
  ApplicationRequest: ApplicationRequest,
  ApplicationResult: ApplicationResult,
  AvailableNumber: AvailableNumber,
  AvailableNumberList: AvailableNumberList,
  BuyIncomingNumberRequest: BuyIncomingNumberRequest,
  CallControlWebhook: CallControlWebhook,
  CallList: CallList,
  CallResult: CallResult,
  CallStatusWebhook: CallStatusWebhook,
  Capabilities: Capabilities,
  CompletionRequest: CompletionRequest,
  CompletionResult: CompletionResult,
  ConferenceList: ConferenceList,
  ConferenceParticipantList: ConferenceParticipantList,
  ConferenceParticipantResult: ConferenceParticipantResult,
  ConferenceRecordingStatusWebhook: ConferenceRecordingStatusWebhook,
  ConferenceResult: ConferenceResult,
  ConferenceStatusWebhook: ConferenceStatusWebhook,
  CreateConference: CreateConference,
  CreateConferenceRequest: CreateConferenceRequest,
  CreateConferenceWebhook: CreateConferenceWebhook,
  CreateWebRTCToken: CreateWebRTCToken,
  Dequeue: Dequeue,
  DequeueWebhook: DequeueWebhook,
  Enqueue: Enqueue,
  ExportList: ExportList,
  ExportRequest: ExportRequest,
  ExportRequestOutput: ExportRequestOutput,
  ExportResult: ExportResult,
  ExportResultOutput: ExportResultOutput,
  FilterLogsRequest: FilterLogsRequest,
  GetDigits: GetDigits,
  GetDigitsWebhook: GetDigitsWebhook,
  GetSpeech: GetSpeech,
  GetSpeechWebhook: GetSpeechWebhook,
  Hangup: Hangup,
  InboundCallWebhook: InboundCallWebhook,
  IncomingNumberList: IncomingNumberList,
  IncomingNumberRequest: IncomingNumberRequest,
  IncomingNumberResult: IncomingNumberResult,
  LeaveConferenceWebhook: LeaveConferenceWebhook,
  LogList: LogList,
  LogResult: LogResult,
  MachineDetectedWebhook: MachineDetectedWebhook,
  MakeCallRequest: MakeCallRequest,
  MessageDeliveryWebhook: MessageDeliveryWebhook,
  MessageRequest: MessageRequest,
  MessageResult: MessageResult,
  MessageStatusWebhook: MessageStatusWebhook,
  MessagesList: MessagesList,
  MutableResourceModel: MutableResourceModel,
  OutDial: OutDial,
  OutDialApiConnectWebhook: OutDialApiConnectWebhook,
  OutDialConnectWebhook: OutDialConnectWebhook,
  OutDialStartWebhook: OutDialStartWebhook,
  PaginationModel: PaginationModel,
  Park: Park,
  Pause: Pause,
  PerclCommand: PerclCommand,
  PerclScript: PerclScript,
  Play: Play,
  PlayEarlyMedia: PlayEarlyMedia,
  QueueList: QueueList,
  QueueMember: QueueMember,
  QueueMemberList: QueueMemberList,
  QueueRequest: QueueRequest,
  QueueResult: QueueResult,
  QueueWaitWebhook: QueueWaitWebhook,
  RecordUtterance: RecordUtterance,
  RecordWebhook: RecordWebhook,
  RecordingList: RecordingList,
  RecordingResult: RecordingResult,
  Redirect: Redirect,
  RedirectWebhook: RedirectWebhook,
  Reject: Reject,
  RemoveFromConference: RemoveFromConference,
  RemoveFromQueueNotificationWebhook: RemoveFromQueueNotificationWebhook,
  SMSTenDLCBrand: SMSTenDLCBrand,
  SMSTenDLCBrandsListResult: SMSTenDLCBrandsListResult,
  SMSTenDLCCampaign: SMSTenDLCCampaign,
  SMSTenDLCCampaignsListResult: SMSTenDLCCampaignsListResult,
  SMSTenDLCPartnerCampaign: SMSTenDLCPartnerCampaign,
  SMSTenDLCPartnerCampaignBrand: SMSTenDLCPartnerCampaignBrand,
  SMSTenDLCPartnerCampaignsListResult: SMSTenDLCPartnerCampaignsListResult,
  SMSTollFreeCampaign: SMSTollFreeCampaign,
  SMSTollFreeCampaignsListResult: SMSTollFreeCampaignsListResult,
  Say: Say,
  SendDigits: SendDigits,
  SetDTMFPassThrough: SetDTMFPassThrough,
  SetListen: SetListen,
  SetTalk: SetTalk,
  Sms: Sms,
  StartRecordCall: StartRecordCall,
  TFN: TFN,
  TFNCampaign: TFNCampaign,
  TerminateConference: TerminateConference,
  TranscribeUtterance: TranscribeUtterance,
  TranscribeUtteranceRecord: TranscribeUtteranceRecord,
  TranscribeWebhook: TranscribeWebhook,
  Unpark: Unpark,
  UpdateCallRequest: UpdateCallRequest,
  UpdateConferenceParticipantRequest: UpdateConferenceParticipantRequest,
  UpdateConferenceRequest: UpdateConferenceRequest,
  Webhook: Webhook,
};

export class ObjectSerializer {
  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === "Date") {
      return expectedType;
    } else {
      if (enumsMap.has(expectedType)) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          var discriminatorType = data[discriminatorProperty];
          if (typeMap[discriminatorType]) {
            return discriminatorType; // use the type given in the discriminator
          } else {
            return expectedType; // discriminator did not map to a type
          }
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string, format: string) {
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.serialize(date, subType, format));
      }
      return transformedData;
    } else if (type === "Date") {
      if (format == "date") {
        let month = data.getMonth() + 1;
        month = month < 10 ? "0" + month.toString() : month.toString();
        let day = data.getDate();
        day = day < 10 ? "0" + day.toString() : day.toString();

        return data.getFullYear() + "-" + month + "-" + day;
      } else {
        return data.toISOString();
      }
    } else {
      if (enumsMap.has(type)) {
        return data;
      }
      if (!typeMap[type]) {
        // in case we dont know the type
        return data;
      }

      // Get the actual type of this object
      type = this.findCorrectType(data, type);

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance: { [index: string]: any } = {};
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.baseName] = ObjectSerializer.serialize(
          data[attributeType.name],
          attributeType.type,
          attributeType.format,
        );
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string, format: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(
          ObjectSerializer.deserialize(date, subType, format),
        );
      }
      return transformedData;
    } else if (type === "Date") {
      return new Date(data);
    } else {
      if (enumsMap.has(type)) {
        // is Enum
        return data;
      }

      if (!typeMap[type]) {
        // dont know the type
        return data;
      }
      let instance = new typeMap[type](data);
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.name] = ObjectSerializer.deserialize(
          data[attributeType.baseName],
          attributeType.type,
          attributeType.format,
        );
      }
      return instance;
    }
  }

  /**
   * Normalize media type
   *
   * We currently do not handle any media types attributes, i.e. anything
   * after a semicolon. All content is assumed to be UTF-8 compatible.
   */
  public static normalizeMediaType(
    mediaType: string | undefined,
  ): string | undefined {
    if (mediaType === undefined) {
      return undefined;
    }
    return mediaType.split(";")[0].trim().toLowerCase();
  }

  /**
   * From a list of possible media types, choose the one we can handle best.
   *
   * The order of the given media types does not have any impact on the choice
   * made.
   */
  public static getPreferredMediaType(mediaTypes: Array<string>): string {
    /** According to OAS 3 we should default to json */
    if (!mediaTypes) {
      return "application/json";
    }

    const normalMediaTypes = mediaTypes.map(this.normalizeMediaType);
    let selectedMediaType: string | undefined = undefined;
    let selectedRank: number = -Infinity;
    for (const mediaType of normalMediaTypes) {
      if (supportedMediaTypes[mediaType!] > selectedRank) {
        selectedMediaType = mediaType;
        selectedRank = supportedMediaTypes[mediaType!];
      }
    }

    if (selectedMediaType === undefined) {
      throw new Error(
        "None of the given media types are supported: " + mediaTypes.join(", "),
      );
    }

    return selectedMediaType!;
  }

  /**
   * Convert data to a string according the given media type
   */
  public static stringify(data: any, mediaType: string): string {
    if (mediaType === "application/json") {
      return JSON.stringify(data);
    }

    throw new Error(
      "The mediaType " +
        mediaType +
        " is not supported by ObjectSerializer.stringify.",
    );
  }

  /**
   * Parse data from a string according to the given media type
   */
  public static parse(rawData: string, mediaType: string | undefined) {
    if (mediaType === undefined) {
      throw new Error("Cannot parse content. No Content-Type defined.");
    }

    if (mediaType === "application/json") {
      return JSON.parse(rawData);
    }

    if (mediaType === "text/plain") {
      return rawData;
    }
    if (mediaType === "text/csv") {
      return rawData;
    }

    throw new Error(
      "The mediaType " +
        mediaType +
        " is not supported by ObjectSerializer.parse.",
    );
  }
}
